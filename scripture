#!/bin/sh

# Function definitions first

# Debugging
rm "$SCRIPTURE_DEBUG" > /dev/null 2>&1
slog () {
	# input: $1 - message
	echo "$(date +%s)	$1" >> "$SCRIPTURE_DEBUG"
}

# Delegate reviewing (getting the grade)
review_card () {
	# input: $1 - card to review
	# output: grade (via "return", so you use $?)

	# Get the Front and Back of your card
	front=$(echo "$1" | cut -d"$DELIMITER" -f 1)
	back=$(echo "$1" | cut -d"$DELIMITER" -f 2)

	# Get grade (q) from user
	echo "$front"

	[ "$SCRIPTURE_HOOK" ] && $SCRIPTURE_HOOK "front_show" "$front" "$back"

	read < /dev/tty
	echo "$back"
	echo

	[ "$SCRIPTURE_HOOK" ] && $SCRIPTURE_HOOK "back_show" "$front" "$back"

	# Loop until user gives a valid answer
	while :
	do
		echo "Enter your grade (0-5):"
		read -r q < /dev/tty
		echo "$q" | grep "^[0-5]$" > /dev/null && break
	done

	[ "$SCRIPTURE_HOOK" ] && $SCRIPTURE_HOOK "card_complete" "$front" "$back" "$q"

	# Function output
	return "$q"
}

# Delegate SM-2 calculation
compute_sm2 () {
	# input: $1 - card, $2 - grade
	# output: new card

	[ "$SCRIPTURE_DEBUG" ] && slog "card: $1"
	[ "$SCRIPTURE_DEBUG" ] && slog "grade: $2"

	# Get the Front and Back of your card
	front=$(echo "$1" | cut -d"$DELIMITER" -f 1)
	back=$(echo "$1" | cut -d"$DELIMITER" -f 2)

	[ "$SCRIPTURE_DEBUG" ] && slog "front: $front"
	[ "$SCRIPTURE_DEBUG" ] && slog "back: $back"

	# Grade alias as per wikipedia
	q="$2"

	# n - repetition number
	n=$(echo "$1" | cut -d"$DELIMITER" -f 3)
	# EF - easiness factor
	EF=$(echo "$1" | cut -d"$DELIMITER" -f 4)
	# I - interval
	I=$(echo "$1" | cut -d"$DELIMITER" -f 5)

	[ "$SCRIPTURE_DEBUG" ] && slog "n: $n"
	[ "$SCRIPTURE_DEBUG" ] && slog "EF: $EF"
	[ "$SCRIPTURE_DEBUG" ] && slog "I: $I"

	# Split depending on q >= 3 or not
	correct_response=0
	[ "$q" -ge 3 ] && correct_response=1
	case $correct_response in
		1)
			[ "$SCRIPTURE_DEBUG" ] && slog "correct response"

			# Correct response
			case "$n" in
				0)
					I=1
					[ "$SCRIPTURE_DEBUG" ] && slog "set I to 1"
					
					;;
				1)
					I=6
					[ "$SCRIPTURE_DEBUG" ] && slog "set I to 6"
					
					;;
				*)
					[ "$SCRIPTURE_DEBUG" ] && slog "set I to $(echo "$I * $EF" | bc -l), aka $I * $EF"
					I=$(echo "$I * $EF" | bc -l)

					;;
			esac

			[ "$SCRIPTURE_DEBUG" ] && slog "set EF to $EF + (0.1 - (5 - $q) * (0.08 + (5 - $q) * 0.02))"
			EF=$(echo "$EF + (0.1 - (5 - $q) * (0.08 + (5 - $q) * 0.02))" | bc -l)
			[ "$SCRIPTURE_DEBUG" ] && slog "which is $EF"

			if [ "$(echo "$EF < 1.3" | bc -l)" = 1 ]
			then
				EF=1.3
				[ "$SCRIPTURE_DEBUG" ] && slog "less than 1.3, so we set to $EF"
			fi

			# Increment n
			n=$((n+1))
			[ "$SCRIPTURE_DEBUG" ] && slog "increment n: set to $n"

			;;
		0)
			[ "$SCRIPTURE_DEBUG" ] && slog "incorrect response"

			# Incorrect response
			n=0
			I=1

			[ "$SCRIPTURE_DEBUG" ] && slog "set n to $n"
			[ "$SCRIPTURE_DEBUG" ] && slog "set I to $I"

			;;
	esac

	# Create new line
	echo "$front$DELIMITER$back$DELIMITER$n$DELIMITER$EF$DELIMITER$I$DELIMITER$(date -I)"
	[ "$SCRIPTURE_DEBUG" ] && slog "new line: $front$DELIMITER$back$DELIMITER$n$DELIMITER$EF$DELIMITER$I$DELIMITER$(date -I)"
}

update_deck () {
	# input: $1 - old card, $2 - new card, $3 - deck file
	# no output: just updating

	# Both lines have to be escaped
	# 's/[]\/()$*.^|[]/\\&/g' is wrong! Do NOT escape () anywhere!

	# Escape lines
	new_line_escaped="$(echo "$2" | sed -e 's/[]$*.^|[]/\\&/g')"
	old_line_escaped="$(echo "$1" | sed -e 's/[]$*.^|[]/\\&/g')"

	# Make the replacement
	sed -i "s/^$old_line_escaped\$/$new_line_escaped/" "$3"
}

# Start of main program

# TSV by default, otherwise use user's preference
DELIMITER=${SCRIPTURE_DELIMITER:-"	"}

# Usage sanitization

# No deck file provided
[ -z "$1" ] && echo "Usage: scripture <deck file>" && exit 1

# Non-existent deck file
cat "$1" > /dev/null 2>&1 || no_file=1
[ "$no_file" ] && echo "No such deck file: $1" && exit 1

# Use "hook" file if it exists
[ -z "$SCRIPTURE_HOOK" ] && cat hook > /dev/null 2>&1 && SCRIPTURE_HOOK=./hook

[ "$SCRIPTURE_HOOK" ] && $SCRIPTURE_HOOK "review_start" "$1"

# Deck file with missing fields
i=1
tmp_file=/tmp/scripture_missing_fields
cp "$1" "$tmp_file"
while read -r line
do
	# Check how many instances of $DELIMITER are in the line
	splits=$(echo "$line" | sed "s/[^$DELIMITER]//g" | awk '{ print length }')

	# Decide what we will do with this number, if there is something to do
	type="invalid"
	[ "$splits" = 5 ] && continue
	[ "$splits" = 0 ] && continue
	[ "$splits" = 1 ] && type="new_card"

	# Commit
	case "$type" in
		"invalid")
			echo "Line $i is invalid."
			echo "Provide exactly two columns (front and back) for new cards that you make."
			echo "See the README for more information."

			exit 1

			;;

		"new_card")
			# arbitrary date that has to be in the past
			date="2021-04-01"

			default_line=$(echo "$line\$DELIMITER0\$DELIMITER2.5\$DELIMITER0\$DELIMITER$date" | sed "s/\$DELIMITER/$DELIMITER/g")

			update_deck "$line" "$default_line" "$tmp_file"

			;;
	esac

	i=$(echo "$i + 1" | bc)
done < "$1"
mv "$tmp_file" "$1"

# Delete temp files
rm /tmp/scripture 2> /dev/null
rm /tmp/scripture_lt4 2> /dev/null
rm /tmp/scripture_upcoming 2> /dev/null

# Determine which cards need to be reviewed
while read -r line
do
	# Skip comments
	[ "$(echo "$line" | sed "s/[^$DELIMITER]//g" | awk '{ print length }')" = 0 ] && continue

	# Get epoch time of last review
	output=$(echo "$line" | cut -d"$DELIMITER" -f 6)
	output=$(date +%s -d"$output")

	# See if time since last review outlasts inter_repetition_interval (I)
	# 86400 --> num of seconds in 24 hours
	I=$(echo "$line" | cut -d"$DELIMITER" -f 5)
	time_since=$(echo "$(date +%s) - $output" | bc -l)

	# Does time since last review fulfills I's requirement
	I_thres=$(echo "$I * 86400" | bc -l)
	[ "$(echo "$time_since > $I_thres" | bc -l)" = "1" ] && echo "$line" >> /tmp/scripture

	# Add review date to /tmp/scripture_upcoming, for telling the user
	# the next time to review, if they have no reviews currently
	next_date=$(echo "$output + $I_thres" | bc -l)
	next_date=${next_date%%.*}
	echo "$next_date" >> /tmp/scripture_upcoming
done < "$1"

# Exit if no cards to review
cat /tmp/scripture > /dev/null 2>&1 || none=1
[ "$none" ] && echo "No cards to review. Next: $(date -d "@$(sort < /tmp/scripture_upcoming | head -1)" -I)" && exit

# Otherwise, start main loop
while :
do
	[ "$SCRIPTURE_HOOK" ] && $SCRIPTURE_HOOK "pre_iteration" "/tmp/scripture"

	while read -r line
	do
		clear

		# Review the card
		review_card "$line"
		grade="$?"

		# Calculate the new variables, ending up with an update line
		new_line_raw=$(compute_sm2 "$line" "$grade")

		# Update the deck file
		update_deck "$line" "$new_line_raw" "$1"

		# SM-2 asks the user to "re-review any cards they marked with a grade less than 4 repeatedly until they give a grade â‰¥ 4"
		# So, we need to create a list of these re-review cards

		# If the grade is less than four, add the card to the list
		[ "$grade" -lt 4 ] && echo "$new_line_raw" >> /tmp/scripture_lt4

	done < /tmp/scripture

	# Exit if none
	cat /tmp/scripture_lt4 > /dev/null 2>&1 || done=1
	if [ "$done" ]
	then
		[ "$SCRIPTURE_HOOK" ] && $SCRIPTURE_HOOK "review_complete" "$1"

		exit
	fi

	# If there are still pending cards, we need to restart
	mv /tmp/scripture_lt4 /tmp/scripture
done
